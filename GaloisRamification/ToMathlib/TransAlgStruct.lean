/-
Copyright (c) 2024 Zixun Guo. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zixun Guo
-/

import Mathlib.Algebra.Algebra.Defs
import Mathlib.Algebra.Algebra.Equiv

/-!
# transfer Algebra structure through ring equiv

In this file, we intro some definitions and lemma to transfer Algebra structure through ring equiv.

## Main Results
* `algOfAlgOnEquivRing`: if `R' ≃+* R`, then `Algebra R' B` can induce a canonical `Algebra R B`.
* `algOfRingEquiv`: if `R' ≃+* R`, then there is a canonical `Algebra R R'` instance.
* `algOfRingEquivReverse`: if `R' ≃+* R`, then there is a canonical `Algebra R' R` instance.
* `ofAlgOnEquivRing_scalar_tower`: shows that the Algebra structure generated by `ofAlgOnEquivRing` is compatible with the Algebra structure generated by `ofRingEquiv`
* `of_equiv_on_equiv_ring`: define a `AlgEquiv` directly from equiv ring
-/

/--
a class to define the ring equiv used in the context
-/
class HasRingEquiv (R R' : Type*) [Add R] [Add R'] [Mul R] [Mul R'] where
  ringEquiv : R ≃+* R'
namespace Algebra


noncomputable def has_ring_equiv_reverse (R R' : Type*) [Add R] [Add R'] [Mul R] [Mul R'] (e: HasRingEquiv R R') : HasRingEquiv R' R where
  ringEquiv := e.ringEquiv.symm

theorem has_ring_equiv_reverse_def (R R' : Type*) [Add R] [Add R'] [Mul R] [Mul R'] (e: HasRingEquiv R R')
: has_ring_equiv_reverse R R' e = ⟨e.ringEquiv.symm⟩ := rfl
/--
transfer Algebra R' B to Algebra R B if R' ≃+* R
-/
noncomputable def algOfAlgOnEquivRing
{R: Type*} (R' B : Type*)
[CommSemiring R] [CommSemiring R'] [Semiring B]
[Algebra R' B] [e: HasRingEquiv R R']:
 Algebra R B where
  smul := fun r b => e.ringEquiv r • b
  toFun := fun r => e.ringEquiv r • 1
  map_one' := by
    simp only [map_one, one_smul]
  map_mul' := by
    intro x y
    simp only [map_mul, Algebra.mul_smul_comm, mul_one]
    rw [<-mul_smul, mul_comm]
  map_zero' := by
    simp only [map_zero, zero_smul]
  map_add' := by
    intro x y
    simp only [map_add,add_smul]
  commutes' := by
    intro r b
    simp only [RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk, Algebra.smul_mul_assoc, one_mul,
      Algebra.mul_smul_comm, mul_one]
  smul_def' :=
    by
      intro r b
      simp only [RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk, Algebra.smul_mul_assoc, one_mul]
      rfl

@[simp]
theorem algOfAlgOnEquivRing_smul_def {R: Type*} {R' B : Type*}
[CommSemiring R] [CommSemiring R'] [Semiring B]
[Algebra R' B] [e: HasRingEquiv R R']
(r: R) (b: B):
let _: Algebra R B := algOfAlgOnEquivRing R' B
r • b = e.ringEquiv r • b := rfl

@[simp]
theorem algOfAlgOnEquivRing_algebraMap_def {R: Type*} {R' B : Type*}
[CommSemiring R] [CommSemiring R'] [Semiring B]
[Algebra R' B] [e: HasRingEquiv R R']
(r: R): @algebraMap R B  _ _ (algOfAlgOnEquivRing R' B) r = e.ringEquiv r • 1 := rfl

/--
if `R' ≃+* R`, then there is a canonical `Algebra R R'` instance.
-/
noncomputable def algOfRingEquiv (R R': Type*) [CommSemiring R] [CommSemiring R'] [e: HasRingEquiv R R'] : Algebra R R'
:= algOfAlgOnEquivRing R' R'

noncomputable def algOfRingEquivReverse (R R': Type*) [CommSemiring R] [CommSemiring R'] [e: HasRingEquiv R R'] : Algebra R' R
:= @algOfRingEquiv R' R _ _ (has_ring_equiv_reverse R R' e)

@[simp]
theorem algOfRingEquiv_smul_def {R R': Type*} [CommSemiring R] [CommSemiring R'] [e: HasRingEquiv R R']
(r: R) (b: R'):
  let _: Algebra R R' := algOfRingEquiv R R'
  r • b = e.ringEquiv r • b := rfl

@[simp]
theorem algOfRingEquiv_algebraMap_def {R R': Type*} [CommSemiring R] [CommSemiring R'] [e: HasRingEquiv R R']
(r: R): @algebraMap R R'  _ _ (algOfRingEquiv R R') r = e.ringEquiv r := by
  simp only [algOfAlgOnEquivRing_algebraMap_def, smul_eq_mul, mul_one]

@[simp]
theorem algOfRingEquiv_algebraMap_def' {R R': Type*} [CommSemiring R] [CommSemiring R'] [e: HasRingEquiv R R']
: @algebraMap R R'  _ _ (algOfRingEquiv R R')  = e.ringEquiv := by
  ext r
  exact algOfRingEquiv_algebraMap_def r

@[simp]
theorem algOfRingEquiv_RingHom {R R': Type*} [CommSemiring R] [CommSemiring R'] [e: HasRingEquiv R R'] : (algOfRingEquiv R R').toRingHom = e.ringEquiv
:= by
  ext x
  rw [show (algOfRingEquiv R R').toRingHom x = e.ringEquiv x • 1 from rfl]
  simp only [smul_eq_mul, mul_one, RingHom.coe_coe]

@[simp]
theorem algOfRingEquivReverse_RingHom {R R': Type*} [CommSemiring R] [CommSemiring R'] [e: HasRingEquiv R R']
: (algOfRingEquivReverse R R').toRingHom = e.ringEquiv.symm := by
  unfold algOfRingEquivReverse
  rw [@algOfRingEquiv_RingHom R' R _ _ (has_ring_equiv_reverse R R' e)]
  rfl

/--
shows that the Algebra structure generated by `ofAlgOnEquivRing` is compatible with the Algebra structure generated by `ofRingEquiv`
-/
def ofAlgOnEquivRing_scalar_tower
{R: Type*} (R' B : Type*)
[CommSemiring R] [CommSemiring R'] [Semiring B]
[Algebra R' B] [e: HasRingEquiv R R']:
@IsScalarTower R R' B (algOfRingEquiv R R').toSMul _ (algOfAlgOnEquivRing R' B).toSMul  := by
  letI smul1_instance := (algOfRingEquiv R R').toSMul
  letI smul2_instance := (algOfAlgOnEquivRing R' B: Algebra R B).toSMul
  let smul1 := fun (s: R) (f: R') => e.ringEquiv s • f
  let smul2 := fun s (f: B) => e.ringEquiv s • f
  apply IsScalarTower.mk
  intro r x y
  show (smul1 r x) • y = smul2 r (x • y)
  unfold_let smul1 smul2
  simp only [smul_eq_mul, map_mul, RingEquiv.apply_symm_apply, mul_smul]
end Algebra


namespace AlgEquiv
open Algebra
/--
define a `AlgEquiv` directly from equiv ring
-/
noncomputable def of_equiv_on_equiv_ring
{R R' A B: Type*}
[CommSemiring R] [CommSemiring R'] [Semiring A] [Semiring B]
[Algebra R A] [Algebra R' B] [e: HasRingEquiv R R']
(ring_eqv: A ≃+* B)
(commutes:
  ∀ r: R, (ring_eqv $ (algebraMap R A) r) = algebraMap R' B (e.ringEquiv r)
)

:  @AlgEquiv R A B _ _ _ _ (algOfAlgOnEquivRing R' B) := by
  letI algR'B: Algebra R B := algOfAlgOnEquivRing R' B
  apply AlgEquiv.ofRingEquiv (f := ring_eqv)
  intro x
  specialize commutes x
  rw [commutes, algOfAlgOnEquivRing_algebraMap_def, algebraMap_eq_smul_one]

end AlgEquiv
